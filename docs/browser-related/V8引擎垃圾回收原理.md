---
title: V8引擎垃圾回收原理
categories:
    - 前端基础
tags: 
    - javascript
date: 2021-05-06
---

## 背景
V8引擎在执行js代码的时候遇到函数时会创建执行上下文并推入到执行栈的栈顶，函数的作用域包含了该函数声明的所有变量，当函数执行完毕时会将对应的函数执行上下文从栈顶弹出，函数的作用域也会随之销毁，其包含的所以变量都会统一被释放并自动回收。但是如果作用域销毁中变量未被回收且支持占用内容，这样的话会导致内存不断增加甚至会引起程序崩溃，因此内存在使用完成之后需要进行还给操作系统以保证重复利用。
V8引擎的内存限制问题： 1. 内存过大，垃圾回收时间就越长，主线程等待时间就越长 2.js的单线程的原因会导致垃圾回收时其他主要逻辑进入暂停状态，浏览器会失去响应。

## 垃圾回收策略
V8采用分代式的垃圾回收策略，根据对象的存活时间将垃圾的回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法

### V8引擎的内存结构组成
1. 新生代（new_space）:大多数对象开始都被分配在这里，这个区域相对较小但是垃圾回收比较频繁。
2. 老生代(old_space)：新生代的对象在存货一段时间后会转移到老生代区中，老生代内存区域的垃圾回收频率相比于前者较低，分为指针区和数据区两个部分。
3. 大对象区(large_object_space)：存放体积超越其他区域的对象，每个对象有自己的内存，垃圾回收不会影响大对象区。
4. 代码区(code_space)：分配代码对象的区域，唯一拥有执行权限的内存区域。
5. map区(map_space)：存放Cell和Map，每个区域存放相同大小的元素。

### 垃圾回收策略
1. 主线程任务执行完毕时进入空闲时会开始进行垃圾回收。

2. 新生代区：
分为两个semispace区域，激活区域称为from空间，未激活的称为to空间。垃圾回收过程主要采用Scavenge算法，当进行垃圾回收时From区域尚有存活对象则会复制到To区域，非存货对象自动回收；当复制完成后From区域和To区域会进行角色互换。
> 新生代内存最大值在64位和32位系统上分别未32M和16M，Scavenge算法缺点牺牲空间换取时间，存储效率较低。

3. 对象晋升：
当一个对象经历多次复制之后仍然存在，则会被认为是生命周期较长的对象，在下一次垃圾回收中会直接被转移到老生代区，这种对象从新生代区到老生代区转移的过程我们称为晋升。
> 对象晋升的条件：a. 是否已经经过依次scavenge算法，即是否已经完成依次From区域到To区域的复制； b.To空间的内存是否已经超过25%

4. 老生代区
由于老生代管理着大量对象，使用scavenge算法存在大量内存上的浪费，因此使用Mark-Sweep(标记清除)和Mark-Compact(标记整理)。

> 引用计数即在垃圾回收时不存在指向某一对象的引用时则可以自动回收该对象。但是存在循环引用时会垃圾回收会出现内存泄漏，因此2012年以后浏览器都采用了标记清除和标记整理算法

Mark-Sweep: 垃圾回收器内部维护一个根列表，然后从所有的根节点出发寻找那些可以被访问到的子节点并将其标记为活动的，无法访问到的节点会被标记为垃圾；最后执行垃圾回收，将非活动的内存块还给操作系统。

Mark-Compact: 在经历一个标记清除后，内存空间可能会存在不连续的状态，后续如果分配一个新对象内存不足时会提前出发GC，但实际上这次GC时不必要的，总内存区域是够用的，只是状态不连续。Mark-Compact就是为了解决内存不连续的问题。

老生代GC过程：标记阶段（从所有根节点出发将可以访问到的子节点标记为活动状态） =>  整理阶段（将活动对象往堆内存的一端移动，如移动至最右侧） => 清除阶段（将活动对象左侧内存全部回收）

老生代优化过程：由于JS的单线程的特点，GC过程会阻塞主线程同步任务的执行；待执行完GC任务后再次恢复执行主线程任务的逻辑，这被称为全停顿，即"stop-the-world"，当老生代中存放大量对象进行GC时势必会花费较长的时间，造成明显的卡顿。V8引入了增量标记（incremental Marking），将原本需要一次性遍历标记的操作改为增量标记，先标记一部分对象然后把权限还给主线程，主线程任务完成时再在原先暂停标记的地方继续执行标记直至完成堆内存中所有根节点的遍历。后续又引入了延迟清除（lazy sweeping）和增量清除（incremental compaction）将整理和清除的阶段也变成了增量的形式，尽可能减少影响主线程的任务，避免卡顿。

### 如何避免内存泄露
1. 减少全局对象的声明，因为采用了标记清除的算法，所以window对象上的节点都可以访问到，因此都会被标记为活动抓太，也就不会被GC回收，需要手动设置为null出发GC。
2. 手动清除定时器
3. 减少闭包的使用
4. 手动清除DOM引用：在以往操作DOM元素时，我们会维护数据字典避免多次获取DOM，因此在removeChild时需要注意也要手动清除这个数据字典中的引用，防止元素占据的内存无法进入GC
5. WeakMap可以解决上述GC存在的内存泄露问题。比如使用WeakMap维护DOM元素的数据字典，这样在DOM元素被移除之后，所占据的内存区域可以自动被回收。WeakMap也可以声明私有变量, 代码如下：
```js
const privateData = new WeakMap();

class Person {
    constructor(name, age) {
        privateData.set(this, { name: name, age: age });
    }

    getName() {
        return privateData.get(this).name;
    }

    getAge() {
        return privateData.get(this).age;
    }
}
```